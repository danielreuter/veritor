"""
Test and documentation for how data binding works in the Veritor API.

This test demonstrates how edge IDs connect data to graphs and enable
verification of computations.
"""

import uuid
import jax.numpy as jnp
from jax import random

from veritor.db.api import WorkloadDatabase
from veritor.db.models import DataBundle, Graph, TensorData
from veritor.prover.simple_inference import SimpleInferenceConfig, SimpleInferenceProver
from veritor.challenger import Challenger


def test_data_binding_mechanics():
    """
    Demonstrates how data binding works through edge IDs.

    Key concepts:
    1. Edge IDs are string identifiers that connect tensors to graph locations
    2. They're generated in different ways depending on the context
    3. The DataBundle uses edge IDs as keys to map data to graph edges
    """

    print("=" * 80)
    print("📚 DATA BINDING MECHANISM DEMONSTRATION")
    print("=" * 80)

    # === PART 1: Understanding Edge ID Generation ===
    print("\n" + "=" * 60)
    print("PART 1: Edge ID Generation Patterns")
    print("=" * 60)

    print("\n1. Operation IDs (for operations in the graph):")
    print("   Format: 'op_{counter:04d}_{context}'")
    print("   Example: 'op_0001_layer_0_linear'")
    print("   Generated by: OperationIDMapper in operation_mapping.py")

    print("\n2. Input/Output IDs (for pass data):")
    print("   Format: '{type}_pass_{index}'")
    print("   Example: 'input_pass_0', 'output_pass_3'")
    print("   Generated by: Test code when storing execution data")

    print("\n3. Weight/Parameter IDs:")
    print("   Format: '{param_name}' (e.g., 'w_0', 'b_1')")
    print("   Example: 'w_0' for layer 0 weights, 'b_2' for layer 2 bias")
    print("   Generated by: Model initialization code")

    print("\n4. Custom IDs (for special data):")
    print("   Format: Arbitrary strings")
    print("   Example: 'gradient_layer_2', 'activation_relu_3'")
    print("   Generated by: Application-specific code")

    # === PART 2: Create Example Data with Edge IDs ===
    print("\n" + "=" * 60)
    print("PART 2: Creating Data with Edge IDs")
    print("=" * 60)

    database = WorkloadDatabase()

    # Create a simple graph
    graph = Graph(
        id=f"demo_graph_{uuid.uuid4().hex[:8]}",
        metadata={"purpose": "data_binding_demo"}
    )
    graph_id = database.store_graph(graph)
    print(f"\n✅ Created graph: {graph_id}")

    # Generate some example tensors
    key = random.PRNGKey(42)

    # Input tensors with edge IDs
    inputs = {}
    for i in range(3):
        edge_id = f"input_pass_{i}"
        tensor_data = TensorData.from_array(
            random.normal(key, (2, 4)),
            edge_id=edge_id  # Edge ID links this tensor to its location
        )
        inputs[edge_id] = tensor_data
        print(f"   Created input: {edge_id} -> shape {tensor_data.shape}")

    # Weight tensors with edge IDs
    weights = {}
    for layer in range(2):
        w_id = f"w_{layer}"
        b_id = f"b_{layer}"

        weights[w_id] = TensorData.from_array(
            random.normal(key, (4, 4)) * 0.1,
            edge_id=w_id
        )
        weights[b_id] = TensorData.from_array(
            random.normal(key, (4,)) * 0.01,
            edge_id=b_id
        )
        print(f"   Created weights: {w_id} -> shape {weights[w_id].shape}")
        print(f"   Created bias: {b_id} -> shape {weights[b_id].shape}")

    # Output tensors with edge IDs
    outputs = {}
    for i in range(3):
        edge_id = f"output_pass_{i}"
        outputs[edge_id] = TensorData.from_array(
            random.normal(key, (2, 4)),
            edge_id=edge_id
        )
        print(f"   Created output: {edge_id} -> shape {outputs[edge_id].shape}")

    # === PART 3: Store Data Bundle with Edge ID Mapping ===
    print("\n" + "=" * 60)
    print("PART 3: Data Bundle Storage")
    print("=" * 60)

    # Create DataBundle - the edge_id in each TensorData acts as the key
    data_bundle = DataBundle(
        id=f"demo_bundle_{uuid.uuid4().hex[:8]}",
        graph_id=graph_id,
        bundle_type="execution",
        inputs=inputs,      # Dict[edge_id, TensorData]
        outputs=outputs,    # Dict[edge_id, TensorData]
        weights=weights,    # Dict[edge_id, TensorData]
        activations={},     # Could store intermediate values
        metadata={"demo": "data_binding"}
    )

    bundle_id = database.store_data_bundle(data_bundle)
    print(f"\n✅ Stored DataBundle: {bundle_id}")
    print(f"   Contains {len(inputs)} inputs")
    print(f"   Contains {len(weights)} weights")
    print(f"   Contains {len(outputs)} outputs")

    # === PART 4: Retrieve and Access Data by Edge ID ===
    print("\n" + "=" * 60)
    print("PART 4: Data Retrieval by Edge ID")
    print("=" * 60)

    # Retrieve the bundle
    retrieved_bundle = database.get_data_bundle(bundle_id)

    print("\n📖 Accessing data by edge ID:")

    # Access specific input by edge ID
    input_1 = retrieved_bundle.inputs["input_pass_1"]
    print(f"   inputs['input_pass_1'] -> TensorData with shape {input_1.shape}")

    # Access specific weight by edge ID
    w_0 = retrieved_bundle.weights["w_0"]
    print(f"   weights['w_0'] -> TensorData with shape {w_0.shape}")

    # Access specific output by edge ID
    output_2 = retrieved_bundle.outputs["output_pass_2"]
    print(f"   outputs['output_pass_2'] -> TensorData with shape {output_2.shape}")

    # Convert to JAX array
    w_0_array = w_0.to_array()
    print(f"\n   Converted w_0 to JAX array: {w_0_array.shape}, dtype={w_0_array.dtype}")

    # === PART 5: How Verification Uses Edge IDs ===
    print("\n" + "=" * 60)
    print("PART 5: How Verification Uses Edge IDs")
    print("=" * 60)

    print("\n🔍 During verification:")
    print("1. Verifier reads graph structure (which defines expected edges)")
    print("2. Verifier retrieves DataBundle for that graph")
    print("3. For each computation step:")
    print("   - Look up input data by edge ID")
    print("   - Perform computation")
    print("   - Compare with output data at corresponding edge ID")
    print("4. Edge IDs ensure correct data binding throughout")

    # === PART 6: Real Example with Prover ===
    print("\n" + "=" * 60)
    print("PART 6: Real Example - How Prover Generates Edge IDs")
    print("=" * 60)

    # Set up a simple prover
    config = SimpleInferenceConfig(
        n_layers=2,
        input_dim=3,
        hidden_dim=4,
        output_dim=2,
        batch_size=1
    )

    challenger = Challenger()
    prover = SimpleInferenceProver(config, challenger)

    # Compile to see operation ID generation
    stablehlo, operation_mapping, _ = prover.compile_workload()

    print("\n📋 Operation ID Mapping (edge IDs for operations):")
    for context, op_id in operation_mapping.items():
        print(f"   '{context}' -> '{op_id}'")

    print("\n🔑 Model Parameters (edge IDs for weights):")
    for param_name in prover.model_params.keys():
        print(f"   '{param_name}' -> weight tensor")

    # === SUMMARY ===
    print("\n" + "=" * 80)
    print("📚 DATA BINDING SUMMARY")
    print("=" * 80)

    print("\n✅ Key Insights:")
    print("1. Edge IDs are simple strings that act as unique identifiers")
    print("2. They're generated using consistent patterns:")
    print("   - Operations: 'op_{counter}_{context}'")
    print("   - Inputs/Outputs: '{type}_pass_{index}'")
    print("   - Weights: Parameter names like 'w_0', 'b_1'")
    print("3. DataBundle stores tensors in dicts keyed by edge ID")
    print("4. This enables precise data-to-graph binding for verification")
    print("5. The edge_id field in TensorData preserves the binding relationship")

    print("\n🔗 Data Flow:")
    print("   Graph Definition → Edge IDs Generated → Data Created with Edge IDs")
    print("   → DataBundle Storage → Retrieval by Edge ID → Verification")

    return {
        "graph_id": graph_id,
        "bundle_id": bundle_id,
        "n_inputs": len(inputs),
        "n_weights": len(weights),
        "n_outputs": len(outputs),
        "operation_ids": list(operation_mapping.values()) if operation_mapping else []
    }


if __name__ == "__main__":
    print("🚀 Running Data Binding Demonstration\n")

    results = test_data_binding_mechanics()

    print(f"\n✅ Demonstration complete!")
    print(f"   Graph ID: {results['graph_id']}")
    print(f"   Bundle ID: {results['bundle_id']}")
    print(f"   Data created: {results['n_inputs']} inputs, "
          f"{results['n_weights']} weights, {results['n_outputs']} outputs")
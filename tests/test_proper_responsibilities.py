"""
Test demonstrating proper responsibility separation in the three-party architecture.

This test shows:
- Challenger generates schedules (not Verifier)
- Verifier only consumes schedules and database
- Prover uses base class with minimal responsibilities
"""

import uuid
from datetime import datetime

import jax.numpy as jnp
import pytest
from jax import random

from veritor.challenger import Challenger
from veritor.db.api import WorkloadDatabase
from veritor.db.ir_store import IRFormat, IRRole
from veritor.db.models import DataBundle, EventType, Graph, TensorData, Trace, TraceEvent
from veritor.prover.simple_inference import SimpleInferenceConfig, SimpleInferenceProver
from veritor.verifier.engine import VerificationConfig
from veritor.verifier.three_party import ThreePartyVerifier


def test_proper_responsibilities(workload_db):
    """
    Test proper responsibility separation in three-party architecture.

    Demonstrates:
    1. Challenger generates schedules (not Verifier)
    2. Verifier only consumes schedules and database
    3. Clean separation of concerns between entities
    """
    database = workload_db

    print("=" * 80)
    print("🏛️  PROPER RESPONSIBILITY SEPARATION TEST")
    print("=" * 80)

    # === CONFIGURATION ===

    prover_config = SimpleInferenceConfig(
        n_layers=4,
        input_dim=2,
        hidden_dim=8,
        output_dim=2,
        batch_size=3,
        seed=42
    )

    verification_config = VerificationConfig(
        execution_rtol=1e-5,
        lsh_rtol=1e-3,
        enable_jit_vs_python=False,
        enable_challenge_verification=False,
        enable_transformation_checks=False
    )

    n_forward_passes = 3

    # === PHASE 1: Initialize Entities ===

    print(f"\n{'=' * 60}")
    print("PHASE 1: Initialize Three-Party Entities")
    print(f"{'=' * 60}")

    # Create entities
    challenger = Challenger()
    prover = SimpleInferenceProver(prover_config, challenger)
    verifier = ThreePartyVerifier(verification_config)

    print("✅ Entities initialized:")
    print("   - Challenger: Will generate schedules")
    print("   - Prover: Uses base class with minimal responsibilities")
    print("   - Verifier: Only consumes schedules and database")

    # === PHASE 2: Compilation and Schedule Generation ===

    print(f"\n{'=' * 60}")
    print("PHASE 2: Compilation and Schedule Generation")
    print(f"{'=' * 60}")

    # Step 1: Prover compiles workload
    print("\n1️⃣  Prover compiling workload...")
    stablehlo, operation_mapping, jitted_workload = prover.compile_workload()

    # Step 2: CHALLENGER generates schedule (NOT Verifier!)
    print("\n2️⃣  CHALLENGER generating schedule (not Verifier)...")
    schedule = challenger.generate_schedule(
        stablehlo=stablehlo,
        operation_mapping=operation_mapping,
        challenge_probability=0.5  # Higher probability for testing
    )

    # Step 3: Verifier receives schedule from Challenger
    print("\n3️⃣  Verifier receiving schedule from Challenger...")
    verifier.receive_schedule(schedule)

    # Create graph in database
    graph = Graph(
        id=f"responsibilities_test_{uuid.uuid4().hex[:8]}",
        metadata={
            "architecture": "proper_responsibilities",
            "test_purpose": "demonstrate_responsibility_separation",
            "n_layers": prover_config.n_layers,
            "operation_count": len(operation_mapping),
            "challenger_generated_schedule": True
        }
    )
    graph_id = database.store_graph(graph)

    # Store StableHLO
    database.ir_store.attach_ir(
        graph_id,
        IRRole.LOGICAL,
        stablehlo,
        IRFormat.STABLEHLO,
        {
            "operation_mapping": operation_mapping,
            "schedule_generator": "Challenger",
            "schedule_consumer": "Verifier"
        }
    )

    print(f"\n✅ Responsibilities properly separated:")
    print(f"   Graph ID: {graph_id}")
    print(f"   Operations: {len(operation_mapping)}")
    print(f"   Schedule generated by: CHALLENGER")
    print(f"   Schedule contains: {len(schedule.operation_challenges)} challenges")
    print(f"   Schedule consumed by: Verifier")

    # === PHASE 3: Execution ===

    print(f"\n{'=' * 60}")
    print("PHASE 3: Execution with Proper Separation")
    print(f"{'=' * 60}")

    all_inputs = {}
    all_outputs = {}
    all_events = []

    for pass_idx in range(n_forward_passes):
        print(f"\n  Pass {pass_idx + 1}/{n_forward_passes}")

        # Generate input
        key = random.PRNGKey(prover_config.seed + pass_idx)
        x = random.normal(key, (prover_config.batch_size, prover_config.input_dim))

        # Store input
        input_id = f"input_pass_{pass_idx}"
        all_inputs[input_id] = TensorData.from_array(x)

        # Execute (Prover queries Challenger)
        output = prover.execute(x)

        # Store output
        output_id = f"output_pass_{pass_idx}"
        all_outputs[output_id] = TensorData.from_array(output)

        # Count challenges
        challenges_in_pass = len([
            c for c in prover.challenge_responses
            if f"pass_{pass_idx}" in c.id or len(c.id.split('_')) > 3
        ])

        print(f"    Challenger queried: {len(challenger.queries_received)} times total")
        print(f"    Challenges in this pass: ~{challenges_in_pass}")

        # Record events
        all_events.append(
            TraceEvent(
                timestamp=datetime.now().timestamp(),
                event_type=EventType.KERNEL_LAUNCH,
                device_id="cpu_0",
                operation_id=f"forward_pass_{pass_idx}",
                data={"pass_idx": pass_idx}
            )
        )

    # Store trace
    trace = Trace(
        id=f"trace_responsibilities_{uuid.uuid4().hex[:8]}",
        graph_id=graph_id,
        start_time=all_events[0].timestamp,
        end_time=all_events[-1].timestamp,
        events=all_events,
        metadata={
            "n_passes": n_forward_passes,
            "n_challenges": len(prover.challenge_responses)
        }
    )
    trace_id = database.store_trace(trace)

    # Store challenges
    for challenge in prover.challenge_responses:
        challenge.metadata["trace_id"] = trace_id
        challenge.metadata["graph_id"] = graph_id
        database.store_challenge(challenge)

    # Store data bundle
    data_bundle = DataBundle(
        id=f"data_responsibilities_{uuid.uuid4().hex[:8]}",
        graph_id=graph_id,
        inputs=all_inputs,
        outputs=all_outputs,
        weights={
            name: TensorData.from_array(param)
            for name, param in prover.model_params.items()
        },
        activations={},
        metadata={"trace_id": trace_id}
    )
    data_id = database.store_data_bundle(data_bundle)

    print(f"\n✅ Execution complete:")
    print(f"   Total challenges: {len(prover.challenge_responses)}")
    print(f"   Trace ID: {trace_id}")
    print(f"   Data ID: {data_id}")

    # === PHASE 4: Verification ===

    print(f"\n{'=' * 60}")
    print("PHASE 4: Verification (Consuming Schedule + Database)")
    print(f"{'=' * 60}")

    # Verifier only reads from database and uses schedule
    print("\n📚 Verifier reading from database...")
    print("📋 Verifier using schedule from Challenger...")

    verification_result = verifier.verify_execution(database, graph_id, trace_id)

    print(f"\n✅ Verification Results:")
    print(f"   Success: {verification_result.success}")
    print(f"   Schedule adherence: {verification_result.metrics.get('schedule_adherence', 'N/A')}")

    # === RESPONSIBILITY VALIDATION ===

    print(f"\n{'=' * 80}")
    print("RESPONSIBILITY VALIDATION")
    print(f"{'=' * 80}")

    # 1. Verify Challenger generates schedules
    assert challenger.schedule is not None, "Challenger should have generated schedule"
    assert len(challenger.schedule.operation_challenges) > 0, "Schedule should have challenges"
    print("✅ Challenger properly generates schedules")

    # 2. Verify Verifier doesn't generate schedules
    assert not hasattr(verifier, 'create_challenge_schedule'), "Verifier should NOT create schedules"
    assert hasattr(verifier, 'receive_schedule'), "Verifier should receive schedules"
    print("✅ Verifier properly consumes schedules (doesn't generate)")

    # 3. Verify Prover uses base class
    from veritor.prover.base import BaseProver
    assert isinstance(prover, BaseProver), "Prover should extend BaseProver"
    assert hasattr(prover, 'build_workload'), "Prover should implement workload building"
    print("✅ Prover properly extends base class")

    # 4. Verify Verifier uses base class
    from veritor.verifier.base import BaseVerifier
    assert isinstance(verifier, BaseVerifier), "Verifier should extend BaseVerifier"
    print("✅ Verifier properly extends base class")

    # 5. Verify entity isolation
    assert not hasattr(prover, 'challenge_schedule'), "Prover should not access schedule"
    assert not hasattr(prover, '_schedule'), "Prover should not have schedule"
    print("✅ Entity isolation maintained")

    # === STATISTICS ===

    challenger_stats = challenger.get_statistics()
    prover_stats = prover.get_statistics()
    verifier_stats = verifier.get_statistics()

    print(f"\n📊 Entity Statistics:")
    print(f"   Challenger:")
    print(f"     - Queries received: {challenger_stats['queries_received']}")
    print(f"     - Challenges issued: {challenger_stats['challenges_issued']}")
    print(f"     - Schedule operations: {challenger_stats['scheduled_operations']}")
    print(f"   Prover:")
    print(f"     - Operations registered: {prover_stats['operations_registered']}")
    print(f"     - Challenges responded: {prover_stats['challenges_responded']}")
    print(f"   Verifier:")
    print(f"     - Has schedule: {verifier_stats['has_schedule']}")
    print(f"     - Scheduled challenges: {verifier_stats.get('scheduled_challenges', 0)}")

    # === SUMMARY ===

    print(f"\n{'=' * 80}")
    print("🎉 PROPER RESPONSIBILITY SEPARATION TEST SUCCESSFUL")
    print(f"{'=' * 80}")

    print("\n✅ Key Achievements:")
    print("   • CHALLENGER generates schedules (not Verifier)")
    print("   • VERIFIER only consumes schedules and database")
    print("   • PROVER uses base class with minimal responsibilities")
    print("   • Clean separation of concerns between all entities")
    print("   • Proper use of base classes for common functionality")

    print("\n🔑 Responsibility Map:")
    print("   • Challenger: Schedule generation, query response")
    print("   • Prover: Workload compilation, execution, challenge response")
    print("   • Verifier: Post-execution verification, schedule adherence")

    return {
        "graph_id": graph_id,
        "trace_id": trace_id,
        "data_id": data_id,
        "verification_result": verification_result,
        "n_challenges": len(prover.challenge_responses),
        "success": verification_result.success
    }


if __name__ == "__main__":
    """Standalone execution."""
    import sys
    sys.path.insert(0, '/Users/danielreuter/projects/veritor')

    from veritor.db.api import WorkloadDatabase

    print("🚀 Running Proper Responsibility Separation Test (Standalone)")

    # Create database
    db = WorkloadDatabase()

    # Run test
    results = test_proper_responsibilities(db)

    # Validate
    assert results["success"], "Verification should succeed"
    assert results["n_challenges"] > 0, "Should have generated challenges"

    print(f"\n✅ Standalone test passed!")
    print(f"   Graph: {results['graph_id']}")
    print(f"   Trace: {results['trace_id']}")
    print(f"   Challenges: {results['n_challenges']}")